use super::{ 
    Ray, Screen,
    math::{ Vec2, Vec3 }
};

/// Camera abstraction
/// 
/// - Generate rays and take a film to be written.
/// - Do not involve render algorithm.
/// 
/// **NOTE:** all arguments follow left-head coord.
pub struct Camera {
    /// position of camera
    pub pos: Vec3,
    /// direction of camera
    pub dir: Vec3,
    /// focal length of camera
    pub focal_len: f64,
    /// viewport of camera
    pub viewport: Vec2, 
    /// screen attachment of camera
    pub attachment: Option<Screen>
}

/// Pixel Rendering Task Iterator
pub struct PRTaskIter<'a> {
    /// the owner camera of iterator
    owner: &'a mut Camera,
    /// the left-upper point of viewport (aka the beginning point).
    origin: Vec3,
    /// viewport's UV coordinate, 
    /// 
    /// which is **flipped** and contains size info(not normalized).
    /// 
    /// **NOTE**
    /// - *U*'s direction is right.
    /// - *V*'s direction is down.
    /// - UV coordinate origin point is in left-upper corner.
    uvdir: (Vec3, Vec3),

    // helper variables for iteration.
    ending: usize,
    counter: usize
}

/// Pixel Rendering Task
pub struct PRTask<'a> {
    /// the ray generated by camera
    pub ray: Ray,
    /// the pixel where ray pass through
    pub pixel: &'a mut Vec3,
}

impl Camera {
    /// Create a new camera.
    /// 
    /// **NOTE** fields `viewport` and `attachment` is completed.
    /// 
    /// please call `set_screen` to initizlied.
    pub fn new(position: Vec3, direction: Vec3, focal_length: f64) -> Camera {
        Camera {
            pos: position, dir: direction,
            focal_len: focal_length,
            viewport: Vec2::from_scalar(0.0),
            attachment: None
        }
    }

    /// Set a screen attachment for camaera.
    /// 
    /// **NOTE** which will set `viewport` at the same time.
    pub fn set_screen(&mut self, screen: Screen, viewport_w: f64) {
        self.attachment = Some(screen);
        
        let aspect = { 
            let attach = self.attachment.as_ref().unwrap();
            attach.height as f64 / attach.width as f64
        };
        let viewport_h = viewport_w * aspect;
        self.viewport = Vec2 { x: viewport_w, y: viewport_h };
    }

    /// Take screen out of camera.
    pub fn take_screen(&mut self) -> Option<Screen> {
        self.attachment.take()
    }

    /// Get rendering task iterator.
    pub fn iter(&mut self) -> PRTaskIter {
        PRTaskIter::new(self)
    }
}

impl<'a> PRTaskIter<'a> {
    pub fn new(owner: &'a mut Camera) -> PRTaskIter<'a> {
        // Caculate the world position of 
        // the first pixel(on left-upper side) of viewport.
        let cam_right = Vec3::new(0.0, 1.0, 0.0)
                                    .cross(owner.dir)
                                    .normalized();
        let cam_up = owner.dir.cross(cam_right)
                                    .normalized();
        let left_v = -cam_right * owner.viewport.x / 2.0;
        let up_v = cam_up * owner.viewport.y / 2.0;

        let uvdir = (cam_right * owner.viewport.x, -cam_up * owner.viewport.y);

        let origin = owner.pos + owner.dir.normalized() * owner.focal_len + left_v + up_v;

        let ending = {
            let attach = owner.attachment.as_ref().unwrap();
            (attach.width * attach.height) as usize
        };

        PRTaskIter { owner, origin, uvdir, ending, counter: 0 }
    }
}

impl<'a> Iterator for PRTaskIter<'a> {
    type Item = PRTask<'a>;

    fn next(&mut self) -> Option<Self::Item> {
        if self.counter == self.ending {
            return None;
        }
        else {
            let attach = self.owner.attachment.as_mut().unwrap();
            
            let u = self.counter % attach.width as usize;
            let v = self.counter / attach.width as usize;
            let index= v * attach.width as usize + u;

            let u_scaler = u as f64 / attach.width as f64;
            let v_scaler = v as f64 / attach.height as f64;
            let direction = self.origin + self.uvdir.0 * u_scaler + self.uvdir.1 * v_scaler;

            let ray = Ray::new(self.owner.pos, direction);
            let pixel = unsafe {
                (&mut attach.buffer[index] as *mut Vec3)
                    .as_mut()
                    .unwrap()
            };

            self.counter += 1;

            return Some(PRTask { ray, pixel });
        }
    }
}